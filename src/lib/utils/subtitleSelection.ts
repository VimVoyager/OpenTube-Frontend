/**
 * Subtitle Selection Utilities
 * 
 * Logic for filtering and prioritizing subtitles based on language preferences
 * and quality (preferring manual over auto-generated).
 */

import type { Subtitle } from '$lib/types';
import { normalizeLanguageCode, getLanguagePriority } from '$lib/utils/languageUtils';

/**
 * Preferred subtitle formats in priority order
 * VTT is preferred for web players as it has the best browser support
 */
const PREFERRED_SUBTITLE_FORMATS = [
	'vtt',
	'srv3',
	'srv2',
	'srv1',
	'ttml'
] as const;

/**
 * Filter out duplicate subtitles for the same language
 * Prefers manual subtitles over auto-generated ones
 */
function deduplicateSubtitles(subtitles: Subtitle[]): Subtitle[] {
	const languageMap = new Map<string, Subtitle>();

	for (const subtitle of subtitles) {
		const normalizedLang = normalizeLanguageCode(subtitle.locale || subtitle.languageTag);
		const existing = languageMap.get(normalizedLang);

		// If no existing subtitle for this language, or if this one is better quality
		if (!existing || (!subtitle.autogenerated && existing.autogenerated)) {
			languageMap.set(normalizedLang, subtitle);
		}
	}

	return Array.from(languageMap.values());
}

/**
 * Filters subtitles to preferred formats
 * Falls back to any available format if preferred formats not found
 */
function filterByFormat(subtitles: Subtitle[]): Subtitle[] {
	// Try preferred formats in order
	for (const format of PREFERRED_SUBTITLE_FORMATS) {
		const filtered = subtitles.filter(sub => 
			sub.format?.toLowerCase() === format.toLowerCase()
		);
		if (filtered.length > 0) {
			return filtered;
		}
	}

	// Fallback: return all if no preferred format found
	return subtitles;
}

/**
 * Sorts subtitles by language priority
 * Primary language first, then English, then alphabetically
 */
function sortByLanguagePriority(subtitles: Subtitle[]): Subtitle[] {
	return subtitles.sort((a, b) => {
		const langA = normalizeLanguageCode(a.locale || a.languageTag);
		const langB = normalizeLanguageCode(b.locale || b.languageTag);

		const priorityA = getLanguagePriority(langA);
		const priorityB = getLanguagePriority(langB);

		if (priorityA !== priorityB) {
			return priorityA - priorityB;
		}

		// Within same priority, prefer manual over auto-generated
		if (a.autogenerated !== b.autogenerated) {
			return a.autogenerated ? 1 : -1;
		}

		return langA.localeCompare(langB);
	});
}

/**
 * Select the best subtitles from available options
 * Returns deduplicated, filtered, and sorted subtitles
 */
export function selectSubtitles(subtitles: Subtitle[] | null | undefined): Subtitle[] {
	if (!subtitles || subtitles.length === 0) {
		return [];
	}

	// Step 1: Filter by preferred formats
	const formatFiltered = filterByFormat(subtitles);

	// Step 2: Remove duplicates (prefer manual over auto-generated)
	const deduplicated = deduplicateSubtitles(formatFiltered);

	// Step 3: Sort by language priority
	const sorted = sortByLanguagePriority(deduplicated);

	return sorted;
}

/**
 * Log selected subtitles for debugging purposes
 */
export function logSelectedSubtitles(subtitles: Subtitle[]): void {
	if (subtitles.length === 0) {
		console.log('No subtitles available');
		return;
	}

	console.log(`Selected ${subtitles.length} subtitle tracks:`);
	subtitles.forEach((subtitle, index) => {
		const type = subtitle.autogenerated ? 'auto' : 'manual';
		const lang = normalizeLanguageCode(subtitle.locale || subtitle.languageTag);
		console.log(
			`  ${index + 1}. ${subtitle.displayLanguageName} (${lang}) - ${subtitle.format} [${type}]`
		);
	});
}