/**
 * Data adapters
 * 
 * Transform raw API responses into clean, component-ready data structures.
 * This layer decouples components from API response formats and provides
 * sensible defaults for missing or malformed data.
 */

import type { Details, Stream, ItagItem, Subtitle } from '$lib/types';
import { normalizeLanguageCode, getLanguageName, extractLanguageFromUrl } from '$lib/utils/languageUtils';

/**
 * Video stream configuration for the player
 */
export interface VideoStreamConfig {
	url: string;
	codec: string;
	mimeType: string;
	width: number;
	height: number;
	bandwidth: number;
	frameRate: number;
	format: string;
	initStart?: number;
	initEnd?: number;
	indexStart?: number;
	indexEnd?: number;
}

/**
 * Audio stream configuration for the player
 */
export interface AudioStreamConfig {
	url: string;
	codec: string;
	mimeType: string;
	bandwidth: number;
	sampleRate: number;
	channels: number;
	format: string;
	language: string;
	languageName: string;
	initStart?: number;
	initEnd?: number;
	indexStart?: number;
	indexEnd?: number;
}

/**
 * Subtitle stream configuration for the player
 */
export interface SubtitleStreamConfig {
	url: string;
	language: string;
	languageName: string;
	format: string;
	mimeType: string;
	kind: 'subtitles' | 'captions';
	isAutoGenerated: boolean;
}

/**
 * Video player configuration derived from selected streams
 */
export interface VideoPlayerConfig {
    videoStream: VideoStreamConfig[] | null;
	audioStream: AudioStreamConfig[] | null;
	subtitleStream: SubtitleStreamConfig[] | null;
	duration: number;
	poster: string;
}

/**
 * Video metadata adapted for display components
 */
export interface VideoMetadata {
	title: string;
	description: string;
	channelName: string;
	channelAvatar: string | null;
	viewCount: number;
	uploadDate: string;
	likeCount: number;
	dislikeCount: number;
	subscriberCount: number;
}

/**
 * Default values for stream properties
 */
const DEFAULT_VIDEO = {
	CODEC: 'avc1.42E01E',
	MIME_TYPE: 'video/mp4',
	WIDTH: 1920,
	HEIGHT: 1080,
	BANDWIDTH: 1000000,
	FRAME_RATE: 30,
	FORMAT: 'MPEG_4'
} as const;

const DEFAULT_AUDIO = {
	CODEC: 'mp4a.40.2',
	MIME_TYPE: 'audio/mp4',
	BANDWIDTH: 128000,
	SAMPLE_RATE: 44100,
	CHANNELS: 2,
	FORMAT: 'M4A'
} as const;

/**
 * Subtitle format to MIME type mapping
 */
const SUBTITLE_MIME_TYPES: Record<string, string> = {
	'vtt': 'text/vtt',
	'srv3': 'application/ttml+xml',
	'srv2': 'application/ttml+xml',
	'srv1': 'application/x-subrip',
	'ttml': 'application/ttml+xml',
	'srt': 'application/x-subrip'
} as const;

/**
 * Extracts language information from a stream
 * Tries multiple sources in order of reliability
 */
function extractLanguageInfo(stream: Stream): { code: string; name: string } {
	const audioLocale = stream.itagItem?.audioLocale;
	const audioTrackId = stream.itagItem?.audioTrackId;
	const audioTrackName = stream.itagItem?.audioTrackName;
	
	let languageCode = audioLocale || audioTrackId;
	
	if (!languageCode) {
		languageCode = extractLanguageFromUrl(stream.url) || 'und';
	}
	
	const normalizedCode = normalizeLanguageCode(languageCode);
	const languageName = audioTrackName || getLanguageName(normalizedCode);
	
	return {
		code: normalizedCode,
		name: languageName
	};
}

/**
 * Extracts byte range information from itagItem
 */
function extractByteRanges(itagItem: ItagItem | undefined): {
	initStart?: number;
	initEnd?: number;
	indexStart?: number;
	indexEnd?: number;
} {
	if (!itagItem) return {};
	
	return {
		initStart: itagItem.initStart,
		initEnd: itagItem.initEnd,
		indexStart: itagItem.indexStart,
		indexEnd: itagItem.indexEnd
	};
}

/**
 * Adapts a single video stream to player configuration format
 */
function adaptVideoStream(stream: Stream): VideoStreamConfig {
	return {
		url: stream.url,
		codec: stream.codec || DEFAULT_VIDEO.CODEC,
		mimeType: DEFAULT_VIDEO.MIME_TYPE,
		width: stream.width || DEFAULT_VIDEO.WIDTH,
		height: stream.height || DEFAULT_VIDEO.HEIGHT,
		bandwidth: stream.bitrate || DEFAULT_VIDEO.BANDWIDTH,
		frameRate: stream.fps || DEFAULT_VIDEO.FRAME_RATE,
		format: stream.format || DEFAULT_VIDEO.FORMAT,
		...extractByteRanges(stream.itagItem)
	};
}

/**
 * Adapts a single audio stream to player configuration format
 */
function adaptAudioStream(stream: Stream): AudioStreamConfig {
	const language = extractLanguageInfo(stream);
	const itagItem = stream.itagItem;
	
	return {
		url: stream.url,
		codec: stream.codec || DEFAULT_AUDIO.CODEC,
		mimeType: DEFAULT_AUDIO.MIME_TYPE,
		bandwidth: stream.bitrate || DEFAULT_AUDIO.BANDWIDTH,
		sampleRate: itagItem?.sampleRate || DEFAULT_AUDIO.SAMPLE_RATE,
		channels: itagItem?.audioChannels || DEFAULT_AUDIO.CHANNELS,
		format: stream.format || DEFAULT_AUDIO.FORMAT,
		language: language.code,
		languageName: language.name,
		...extractByteRanges(itagItem)
	};
}

/**
 * Adapts a single subtitle to player configuration format
 */
function adaptSubtitleStream(subtitle: Subtitle): SubtitleStreamConfig {
	const language = normalizeLanguageCode(subtitle.locale || subtitle.languageTag);
	const format = subtitle.format?.toLowerCase() || 'vtt';
	
	return {
		url: subtitle.url,
		language,
		languageName: subtitle.displayLanguageName || getLanguageName(language),
		format,
		mimeType: SUBTITLE_MIME_TYPES[format] || 'text/vtt',
		kind: subtitle.autogenerated ? 'captions' : 'subtitles',
		isAutoGenerated: subtitle.autogenerated
	};
}

/**
 * Adapt video and audio streams into player configuration
 */
export function adaptPlayerConfig(
	videoStreams: Stream[] | undefined,
	audioStreams: Stream[] | undefined,
	subtitles: Subtitle[] | undefined,
	duration: number,
	posterUrl: string
): VideoPlayerConfig {
	return { 
		videoStream: videoStreams?.length 
			? videoStreams.map(adaptVideoStream)
			: null,
		audioStream: audioStreams?.length 
			? audioStreams.map(adaptAudioStream)
			: null,
		subtitleStream: subtitles?.length
			? subtitles.map(adaptSubtitleStream)
			: null,
		duration,
		poster: posterUrl
	};
}

/**
 * Selects the best quality avatar from available options
 * Prefers medium quality (index 2), falls back to first available
 */
function selectBestAvatar(avatars: Details['uploaderAvatars'], fallback: string): string {
	if (!avatars || avatars.length === 0) return fallback;
	
	// Prefer medium quality (usually index 2)
	return avatars[2]?.url || avatars[0]?.url || fallback;
}

/**
 * Adapt video details into metadata for display
 */
export function adaptVideoMetadata(
	details: Details,
	defaultAvatar: string
): VideoMetadata {
		return {
		title: details.videoTitle || 'Untitled Video',
		description: details.description?.content || 'No description available',
		channelName: details.channelName || 'Unknown Channel',
		channelAvatar: selectBestAvatar(details.uploaderAvatars, defaultAvatar),
		viewCount: details.viewCount || 0,
		uploadDate: details.uploadDate || '',
		likeCount: details.likeCount || 0,
		dislikeCount: details.dislikeCount || 0,
		subscriberCount: details.channelSubscriberCount || 0,
	};
}

/**
 * Calculate video duration from stream metadata
 */
export function calculateDuration(
	videoStreams: Stream[] | undefined,
	audioStreams: Stream[] | undefined
): number {
	const durationMs = 
		videoStreams?.[0]?.itagItem?.approxDurationMs ||
		audioStreams?.[0]?.itagItem?.approxDurationMs ||
		0;
	
	return durationMs / 1000;
}

